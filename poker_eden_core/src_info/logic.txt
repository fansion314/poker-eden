// logic.rs
use crate::card::*;
use crate::message::{ServerMessage, ShowdownResult};
use crate::state::*;
use std::collections::HashMap;

// --- 核心游戏流程函数 ---
impl GameState {
    /// 开始新的一局游戏
    ///
    /// 这个函数负责初始化一局德州扑克所需的所有状态。
    /// - 重置奖池、公共牌等。
    /// - 为所有参与的玩家设置初始状态。
    /// - 创建一副新牌，洗牌，并给每个玩家发两张底牌。
    /// - 处理大小盲注。
    /// - 设置游戏阶段为 PreFlop，并确定第一个行动的玩家。
    ///
    /// # Returns
    /// 返回一个消息列表，描述新牌局开始时发生的事件 (如：盲注、轮到谁行动等)。
    /// # Panics
    /// 如果活跃玩家少于2人，则会 panic，因为游戏无法开始。
    ///
    /// # 实现思路
    /// 1.  **清理和准备**: 将离线或筹码为0的玩家设为`SittingOut`，然后从所有就座玩家中筛选出本局的活跃玩家列表`hand_player_order`。
    /// 2.  **状态重置**: 重置奖池(`pot`)、公共牌(`community_cards`)、下注额(`cur_bets`)等局内状态。
    /// 3.  **发牌**: 生成一副只含所需数量的牌并洗牌，然后给每位活跃玩家发两张底牌。
    /// 4.  **盲注处理**: 根据玩家人数（特别是两人单挑的特殊规则）确定大小盲注和第一个行动者的位置，并强制他们下注。
    /// 5.  **最终设置**: 将游戏阶段设为 `PreFlop`，并设置当前行动玩家的索引 `cur_player_idx`。
    /// 6.  **消息生成**: 在整个过程中，将关键事件（如牌局开始、盲注下注、轮到谁行动）包装成 `ServerMessage` 并返回。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 一个包含牌局开始时所有事件通知的消息列表。
    pub fn start_new_hand(&mut self) -> Vec<ServerMessage>;

    /// 处理自动玩家（如离线玩家）的行动。
    ///
    /// 服务器可以在一个循环中调用此函数，直到它返回 false。
    /// 当轮到一个需要人类输入的玩家时，它会返回 false。
    ///
    /// # Returns
    /// - `(bool, Vec<ServerMessage>)`: 元组的第一个元素表示是否执行了自动行动，
    ///   第二个元素是该行动产生的消息列表。
    ///
    /// # 实现思路
    /// 1.  检查当前是否轮到某个玩家行动，且该玩家是自动玩家（例如 `Offline` 状态）。
    /// 2.  如果不是，则直接返回 `(false, [])`。
    /// 3.  如果是，则为其决定一个简单的默认动作：如果无需跟注，则`Check`（过牌）；否则`Fold`（弃牌）。
    /// 4.  调用核心的 `handle_player_action` 函数来处理这个自动生成的动作。
    /// 5.  返回 `(true, ...)` 以及 `handle_player_action` 生成的消息列表。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `(bool, Vec<ServerMessage>)`: 一个元组，`bool`值表示是否执行了自动行动，`Vec`包含该行动产生的消息。
    pub fn tick(&mut self) -> (bool, Vec<ServerMessage>);

    /// 处理单个玩家的动作
    ///
    /// 这是游戏逻辑的核心驱动函数之一。它接收一个玩家的动作，
    /// 验证其合法性，然后更新游戏状态。
    /// - 扣除筹码，增加奖池。
    /// - 更改玩家状态 (如 Folded, AllIn)。
    /// - 更新当前轮的最大下注额。
    ///
    /// 在处理完动作后，它会检查当前下注轮是否结束。
    /// 如果是，则推进到下一个游戏阶段 (e.g., Flop -> Turn)。
    /// 如果否，则将行动权转移给下一个玩家。
    ///
    /// # Returns
    /// 返回一个消息列表，描述该动作引发的所有状态变更。
    ///
    /// # 实现思路
    /// 1.  **验证**: 检查执行动作的玩家是否是当前轮到的玩家。
    /// 2.  **执行动作**: 根据 `PlayerAction` (Fold, Check, Call, Bet/Raise) 更新状态。
    ///     - **Fold**: 改变玩家状态。
    ///     - **Check/Call**: 验证合法性，更新筹码和奖池。
    ///     - **Bet/Raise**: 验证下注/加注额是否符合规则（最小下注额、最小加注额），更新筹码、奖池、`cur_max_bet`和`last_raise_amount`。加注后，会重置其他玩家的`player_has_acted`状态，以开启新一轮行动。
    /// 3.  **生成消息**: 创建一个 `PlayerActed` 消息。
    /// 4.  **检查手牌结局**: 判断是否只剩一个未弃牌的玩家，如果是则直接结束牌局并分池。
    /// 5.  **检查本轮结局**: 调用 `check_betting_round_over()` 判断本轮下注是否结束。
    /// 6.  **推进**: 如果本轮结束，调用 `advance_to_next_phase()`；否则，调用 `advance_to_next_player()`。
    /// 7.  返回所有生成的消息。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    /// - `player_id: PlayerId`: 执行动作的玩家ID。
    /// - `action: PlayerAction`: 玩家执行的具体动作。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 一个包含该动作及其后续状态变更所产生的所有事件消息的列表。
    pub fn handle_player_action(
        &mut self,
        player_id: PlayerId,
        action: PlayerAction,
    ) -> Vec<ServerMessage>;

    // --- 辅助逻辑函数 ---

    /// 将行动权转移给下一位合法的玩家
    ///
    /// # 实现思路
    /// 从当前玩家索引 `cur_player_idx` 开始，循环遍历 `hand_player_order` 列表。
    /// 找到第一个状态为 `Playing` 且在本轮尚未完成最终行动 (`player_has_acted` 为 false) 的玩家。
    /// 找到后，更新 `cur_player_idx` 为该玩家的索引，并返回一个 `NextToAct` 消息。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 若找到下一个行动者，返回包含一个 `NextToAct` 消息的向量；否则返回空向量。
    fn advance_to_next_player(&mut self) -> Vec<ServerMessage>;

    /// 检查当前下注轮是否结束
    ///
    /// 下注轮结束的条件是:
    /// 1. 所有未弃牌 (Folded) 且未全下 (All-In) 的玩家，都已经在这一轮行动过 (player_has_acted == true)。
    /// 2. 并且，他们所有人的当前下注额 (cur_bets) 都等于当前轮的最高下注额 (cur_max_bet)。
    ///
    /// 这个逻辑正确地处理了:
    /// - 翻牌前大盲注的 "选择权" (Option): 如果前面玩家只是跟注，行动轮到大盲时，他的 `player_has_acted` 仍为 false，所以本轮不会结束，他可以选择过牌或加注。
    /// - 加注后重新开始一轮: 当有人加注，其他玩家的 `player_has_acted` 会被重置为 false，强迫他们必须再次行动。
    ///
    /// # 实现思路
    /// 筛选出所有状态为 `Playing` 的玩家（即未弃牌也未全下）。
    /// 对这个玩家群体进行检查：
    /// 1.  他们每个人的 `cur_bets` 是否都等于 `cur_max_bet`？
    /// 2.  他们每个人的 `player_has_acted` 标志是否都为 `true`？
    /// 只有当这两个条件同时满足时，本轮下注才算结束。如果没有任何玩家需要行动（例如都All-in了），也视为结束。
    ///
    /// # 输入
    /// - `&self`: 对当前游戏状态的不可变引用。
    ///
    /// # 输出
    /// `bool`: 如果下注轮结束，返回 `true`，否则返回 `false`。
    fn check_betting_round_over(&self) -> bool;

    /// 推进到下一个游戏阶段
    ///
    /// 在一轮下注结束后调用。
    /// - 根据当前阶段，发出公共牌 (Flop, Turn, River)。
    /// - 重置新一轮的下注状态。
    /// - 确定下一轮第一个行动的玩家 (通常是庄家左边的第一个未弃牌玩家)。
    /// - 如果已是 River 结束，则进入 Showdown (摊牌)阶段。
    ///
    /// # 实现思路
    /// 1.  **重置下注状态**: 将所有玩家的 `player_has_acted` 设为 `false`，并重置 `last_raise_amount`。
    /// 2.  **推进阶段**: 根据当前 `phase` (PreFlop, Flop, Turn)，更新到下一个阶段，并从 `deck` 中发出相应的公共牌，生成 `CommunityCardsDealt` 消息。
    /// 3.  **判断特殊情况**: 检查剩余可行动玩家是否少于两人。如果是，则不再进行下注，直接发出所有剩余的公共牌，然后进入摊牌(`handle_showdown`)。
    /// 4.  **常规推进**: 如果还有至少两名玩家可以行动，则确定下一轮第一个行动的玩家，并发出 `NextToAct` 消息。
    /// 5.  如果当前阶段是 `River`，则直接进入摊牌。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 包含发公共牌、轮到谁行动或摊牌结果等事件的消息列表。
    fn advance_to_next_phase(&mut self) -> Vec<ServerMessage>;

    /// 处理摊牌逻辑
    ///
    /// - 找出所有未弃牌的玩家。
    /// - 调用新的分池函数来处理奖金分配
    ///
    /// # 实现思路
    /// 这是一个协调函数，它按顺序调用两个核心的结算步骤：
    /// 1.  调用 `return_uncalled_bets()` 来处理并返还没有被完全跟注的下注。
    /// 2.  调用 `distribute_pots()` 来处理复杂的（可能包含边池的）奖池分配。
    /// 3.  合并并返回这两个步骤生成的所有消息。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 包含摊牌结算过程所有事件的消息列表。
    fn handle_showdown(&mut self) -> Vec<ServerMessage>;

    /// 在摊牌前，返还任何玩家未被跟注的下注部分 (逻辑已修正)
    /// 例如: P1下注500，P2只有200并跟注All-in。P1未被跟注的300将在这里返还。
    ///
    /// # 实现思路
    /// 1.  找出所有参与摊牌的玩家及其最终下注额。
    /// 2.  按下注额从高到低排序。
    /// 3.  如果玩家数少于2，或者最高下注额不大于第二高下注额，则无需返还。
    /// 4.  否则，计算最高下注与第二高下注的差额，这就是需要返还的金额。
    /// 5.  将这笔金额从 `pot` 中扣除，加回到最高下注玩家的 `stack` 中，并更新该玩家的 `cur_bets`，然后生成一个 `BetReturned` 消息。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 如果有筹码被返还，则返回包含一个 `BetReturned` 消息的向量。
    fn return_uncalled_bets(&mut self) -> Vec<ServerMessage>;

    /// 处理包含边池的复杂奖池分配
    ///
    /// 这是本次修改的核心。算法如下：
    /// 1. 收集所有玩家（包括已弃牌）的最终下注额，以及未弃牌玩家的最终牌力。
    /// 2. 找出所有不同的下注额度（例如：50, 200, 500），并从小到大排序。
    /// 3. 逐级处理每个额度，形成主池和边池。
    ///    - 例如，第一个池由最小下注额（如50）构成。所有下注额大于等于50的玩家都向此池投入50。
    ///    - 从所有有资格争夺此池（下注额>=50且未弃牌）的玩家中找出赢家，分配奖金。
    ///    - 处理下一个额度（如200），形成边池。投入额为 (200-50)=150。所有下注额大于等于200的玩家都向此池投入150。
    ///    - 找出有资格争夺此边池的赢家，分配奖金。
    /// 4. 循环此过程，直到所有奖池分配完毕。
    ///
    /// # 实现思路
    /// 1.  **收集信息**: 汇总所有玩家的最终下注额，并为所有未弃牌的玩家评定最终牌力(`HandRank`)。
    /// 2.  **确定分池层级**: 从所有玩家的下注额中提取出所有不重复的数值，并从小到大排序，这些数值就是划分主池和边池的“水位线”。
    /// 3.  **逐级分池**: 遍历每一个“水位线”，计算该层级的边池大小。
    /// 4.  **确定赢家**: 对于每个边池，找出所有下注额达到该水位线且未弃牌的玩家，在他们之中比较牌力，找到一个或多个赢家。
    /// 5.  **分配奖金**: 将当前边池的奖金平分给所有赢家，并累加到他们的 `total_winnings` 中。
    /// 6.  **循环**: 重复3-5步，直到所有层级的池都分配完毕。
    /// 7.  **生成结果**: 根据每个玩家的牌力、底牌和总赢款，构建 `ShowdownResult` 列表，并包含在一个 `Showdown` 消息中返回。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 返回包含一个 `Showdown` 消息的向量，其中详细描述了每个玩家的牌、牌型和输赢结果。
    fn distribute_pots(&mut self) -> Vec<ServerMessage>;

    /// 当只剩下一组赢家时（例如所有人都弃牌了），分配底池。
    ///
    /// # 实现思路
    /// 这是一个简化的分池逻辑。将总奖池 `pot` 的金额平分给 `winners` 列表中的所有玩家。
    /// 处理可能无法整除的余数，将其分给列表中的第一个玩家。
    /// 更新每个赢家玩家的 `stack` 和 `wins` 计数。
    /// 为每个赢家创建一个 `ShowdownResult`（可能会评估他们的手牌，如果牌局进展足够远），并最终返回一个包含这些结果的 `Showdown` 消息。
    ///
    /// # 输入
    /// - `&mut self`: 对当前游戏状态的可变引用。
    /// - `winners: Vec<PlayerId>`: 赢得底池的玩家ID列表。
    ///
    /// # 输出
    /// `Vec<ServerMessage>`: 返回包含一个 `Showdown` 消息的向量。
    fn distribute_pot_to_single_winner_group(
        &mut self,
        winners: Vec<PlayerId>,
    ) -> Vec<ServerMessage>;
}